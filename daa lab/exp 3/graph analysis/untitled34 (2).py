# -*- coding: utf-8 -*-
"""Untitled34.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tlA9XRxKYCHs7RJkgWRC50iBmC-FR1oo
"""

import matplotlib.pyplot as plt

# Data from C program (replace with actual timings)
n_values = [10000, 20000, 30000, 40000, 50000, 60000]
recursive_times = [0.007, 0.010, 0.016, 0.017, 0.021, 0.033]  # Example times for recursive insertions
iterative_times = [0.009, 0.009, 0.011, 0.019, 0.018, 0.019]  # Example times for iterative insertions

# Create the plot
plt.plot(n_values, recursive_times, label='Recursive Insertion', marker='o')
plt.plot(n_values, iterative_times, label='Iterative Insertion', marker='o')

# Add labels and title
plt.xlabel('n (Size of the tree)')
plt.ylabel('Time (seconds)')
plt.title('Recursive vs Iterative BST Insertion Time')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Data from the C program output (replace with actual times)
n_values = [10000, 20000, 30000, 40000, 50000, 60000]
merge_sort_times = [0.015, 0.030, 0.050, 0.070, 0.090, 0.120]  # Example times for Merge Sort
quick_sort_times = [0.010, 0.025, 0.040, 0.060, 0.080, 0.110]  # Example times for Quick Sort

# Create the plot
plt.plot(n_values, merge_sort_times, label='Merge Sort', marker='o')
plt.plot(n_values, quick_sort_times, label='Quick Sort', marker='o')

# Add labels and title
plt.xlabel('n (Size of the Array)')
plt.ylabel('Time (seconds)')
plt.title('Merge Sort vs Quick Sort Performance')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Data from the C program output (replace with actual times)
n_values = [10000, 20000, 30000, 40000, 50000, 60000]
merge_sort_times = [0.005, 0.002, 0.007, 0.029, 0.011, 0.019]  # Example times for Merge Sort
quick_sort_times = [0.002, 0.002, 0.006, 0.006, 0.008, 0.011]  # Example times for Quick Sort

# Create the plot
plt.plot(n_values, merge_sort_times, label='Merge Sort', marker='o')
plt.plot(n_values, quick_sort_times, label='Quick Sort', marker='o')

# Add labels and title
plt.xlabel('n (Size of the Array)')
plt.ylabel('Time (seconds)')
plt.title('Merge Sort vs Quick Sort Performance')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Data from the C program output (replace with actual times)
n_values = [100, 200, 300]  # Number of nodes for each test case

dijkstra_times = [0.0001, 0.0002, 0.0003]  # Example times for Dijkstra
bellman_ford_times = [0.0000, 0.0002, 0.0002]  # Example times for Bellman-Ford

# Create the plot
plt.plot(n_values, dijkstra_times, label='Dijkstra', marker='o')
plt.plot(n_values, bellman_ford_times, label='Bellman-Ford', marker='o')

# Add labels and title
plt.xlabel('Number of Nodes (V)')
plt.ylabel('Time (seconds)')
plt.title('Dijkstra vs Bellman-Ford Performance')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()



import matplotlib.pyplot as plt

# Hypothetical execution times (in ms) for each algorithm at different input sizes (n)
n_values = [10, 20, 30, 40, 50, 60]
backtracking_times = [50, 100, 150, 200, 250, 300]  # Example times for Backtracking
branch_bound_times = [30, 60, 90, 120, 150, 180]   # Example times for Branch & Bound
dp_times = [5, 10, 15, 20, 30, 40]                 # Example times for Dynamic Programming

# Create the plot
plt.plot(n_values, backtracking_times, label='Backtracking', marker='o', linestyle='--')
plt.plot(n_values, branch_bound_times, label='Branch & Bound', marker='s', linestyle='-.')
plt.plot(n_values, dp_times, label='Dynamic Programming', marker='^', linestyle='-')

# Add labels and title
plt.xlabel('Number of Items (n)')
plt.ylabel('Time (milliseconds)')
plt.title('Knapsack Problem: Algorithm Performance Comparison')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Example data for matrix sizes and times (replace with actual data)
matrix_sizes = [16, 32, 64, 128, 256, 512]
traditional_times = [0.0001, 0.0004, 0.0016, 0.0064, 0.0256, 0.1024]  # Example data
strassen_times = [0.00008, 0.0002, 0.0008, 0.0025, 0.0100, 0.0400]      # Example data

# Create the plot
plt.plot(matrix_sizes, traditional_times, label="Traditional Multiplication", marker='o', linestyle='--')
plt.plot(matrix_sizes, strassen_times, label="Strassen's Multiplication", marker='s', linestyle='-.')

# Add labels and title
plt.xlabel('Matrix Size (n)')
plt.ylabel('Time (seconds)')
plt.title('Matrix Multiplication: Traditional vs Strassen\'s Algorithm')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Example data for matrix sizes and times (replace with actual data)
matrix_sizes = [ 32, 64, 128, 256, 512,1024]
traditional_times = [0.001, 0.002, 0.009, 0.076, 0.598, 5.033]  # Example data
strassen_times = [0.000, 0.001, 0.009, 0.597, 5.191, 50.033]      # Example data

# Create the plot
plt.plot(matrix_sizes, traditional_times, label="Traditional Multiplication", marker='o', linestyle='--')
plt.plot(matrix_sizes, strassen_times, label="Strassen's Multiplication", marker='s', linestyle='-.')

# Add labels and title
plt.xlabel('Matrix Size (n)')
plt.ylabel('Time (seconds)')
plt.title('Matrix Multiplication: Traditional vs Strassen\'s Algorithm')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Data from the C program output (replace with actual times)

dijkstra_times = [0.0001,0.0002,0.0003]  # Example times for Dijkstra
bellman_ford_times = [0.0000,0.0002,0.0002]  # Example times for Bellman-Ford

# Create the plot
plt.plot(n_values, dijkstra_times, label='Dijkstra', marker='o')
plt.plot(n_values, bellman_ford_times, label='Bellman-Ford', marker='o')

# Add labels and title
plt.xlabel('Number of Nodes (V)')
plt.ylabel('Time (seconds)')
plt.title('Dijkstra vs Bellman-Ford Performance')
plt.legend()

# Show the plot
plt.grid(True)
plt.show()